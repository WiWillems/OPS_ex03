2b) Use the Makefile to compile and link the code by typing make.
• What happens when you type make clean?

it wipes out all the output files that were made

• And when you type make twice in a row?

the syntax results in an error unable to target a 'make' and asks you to stop

• What does make -j4 (after make clean) do (see man make)?

it specifies that you want to start a make with 4 jobs(commands)

2c)
1. What happens when you provide an incorrect argument for each of the three arguments?

The correct error will print on screen for each of the parameters 

2. Run ./display e 1500 . What happens when, during execution:
• you press Ctrl-C
a ^C character shows up in the row

• you press Ctrl-Z
the program instantly pauses with a message

– after Ctrl-Z type jobs
– then type fg
– what does fg stand for? See man fg

job control, it runs jobs in the foreground

– what happens when you type kill %i (instead of fg), where i is the number
between square brackets returned by jobs?

kills the program for that number of lines

3. Run time ./display p 100000 . and then time ./display w 100000 .
• which is faster? Why?
print is faster than write because it makes use of a memory buffer.

• what happens when you press Ctrl-C during one of these commands?
it stops the process with a ^C


2d)

Start two instances of display as follows13
./display e 1500 . & ./display e 1500 + &
What happens when you replace the ampersand (&) by a semicolon (;)? Why?

Ampersand combines the two commands while semicolon sets the tasks in line with . going first and then + after it finishes

2e)


Start three instances of display as follows
nice -19 ./display e 1500 . & nice -10 ./display e 1500 - & ./display
e 1500 + &
Explain what happens.

the code prints +.- which means that the task '+' has the highest priority with '.' in middle and '-' as lowest. Logically it should be '.' -> '-' -> '+' because of the nice values but that is not the case here.


2f)

Repeat the three commands above, once with the p (printf()) and once with the w (write())
printing mode. If you don’t see differences, print more characters. One of these functions uses
buffering. Which function is that? How do you know? How does buffering affect the speed of
the program?

printf makes use of a memory buffer where the input gets stored until the memory buffer reaches its limit and a new write begins. This saves a lot of time. I got this information from
https://stackoverflow.com/questions/11213031/write-or-printf-which-is-faster




